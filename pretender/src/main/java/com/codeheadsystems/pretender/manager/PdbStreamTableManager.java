package com.codeheadsystems.pretender.manager;

import com.codeheadsystems.dbu.model.Database;
import javax.inject.Inject;
import javax.inject.Singleton;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Manages dynamic creation and deletion of stream storage tables.
 * Each DynamoDB table with streams enabled gets a corresponding SQL table for storing stream records.
 */
@Singleton
public class PdbStreamTableManager {

  private static final Logger log = LoggerFactory.getLogger(PdbStreamTableManager.class);
  private static final String TABLE_PREFIX = "pdb_stream_";
  private static final String INDEX_PREFIX = "idx_stream_";

  private final Jdbi jdbi;
  private final Database database;

  /**
   * Instantiates a new Pdb stream table manager.
   *
   * @param jdbi     the jdbi
   * @param database the database configuration
   */
  @Inject
  public PdbStreamTableManager(final Jdbi jdbi, final Database database) {
    log.info("PdbStreamTableManager({}, {})", jdbi, database);
    this.jdbi = jdbi;
    this.database = database;
  }

  /**
   * Creates a stream storage table for a DynamoDB table.
   *
   * @param tableName the DynamoDB table name
   */
  public void createStreamTable(final String tableName) {
    final String streamTableName = getStreamTableName(tableName);
    log.info("createStreamTable: {}", streamTableName);

    jdbi.useHandle(handle -> {
      // Create the stream table
      final String createTableSql = buildCreateTableSql(streamTableName);
      handle.execute(createTableSql);

      // Create index on event_timestamp for efficient cleanup queries
      try {
        final String timestampIndexName = INDEX_PREFIX + sanitizeTableName(tableName) + "_timestamp";
        final String createTimestampIndexSql = String.format(
            "CREATE INDEX \"%s\" ON \"%s\" (event_timestamp)",
            timestampIndexName,
            streamTableName
        );
        handle.execute(createTimestampIndexSql);
      } catch (Exception e) {
        log.warn("Failed to create timestamp index for stream table {}: {}", streamTableName, e.getMessage());
      }

      // Create index on sequence_number for efficient record retrieval
      try {
        final String sequenceIndexName = INDEX_PREFIX + sanitizeTableName(tableName) + "_sequence";
        final String createSequenceIndexSql = String.format(
            "CREATE INDEX \"%s\" ON \"%s\" (sequence_number)",
            sequenceIndexName,
            streamTableName
        );
        handle.execute(createSequenceIndexSql);
      } catch (Exception e) {
        log.warn("Failed to create sequence index for stream table {}: {}", streamTableName, e.getMessage());
      }

      log.debug("Created stream table: {}", streamTableName);
    });
  }

  /**
   * Drops a stream storage table.
   *
   * @param tableName the DynamoDB table name
   */
  public void dropStreamTable(final String tableName) {
    final String streamTableName = getStreamTableName(tableName);
    log.info("dropStreamTable: {}", streamTableName);

    jdbi.useHandle(handle -> {
      final String dropTableSql = String.format(
          "DROP TABLE IF EXISTS \"%s\" CASCADE",
          streamTableName
      );
      handle.execute(dropTableSql);
      log.debug("Dropped stream table: {}", streamTableName);
    });
  }

  /**
   * Gets the SQL table name for storing stream records.
   *
   * @param dynamoTableName the DynamoDB table name
   * @return the stream table name
   */
  public String getStreamTableName(final String dynamoTableName) {
    return TABLE_PREFIX + sanitizeTableName(dynamoTableName);
  }

  /**
   * Builds the CREATE TABLE SQL for a stream storage table.
   *
   * @param tableName the table name
   * @return the CREATE TABLE SQL
   */
  private String buildCreateTableSql(final String tableName) {
    // Choose column types based on database
    final String jsonColumnType = database.usePostgresql() ? "JSONB" : "CLOB";
    final String autoIncrementType = database.usePostgresql() ? "BIGSERIAL" : "BIGINT GENERATED BY DEFAULT AS IDENTITY";

    return String.format(
        "CREATE TABLE IF NOT EXISTS \"%s\" (" +
            "sequence_number %s PRIMARY KEY, " +
            "event_id VARCHAR(128) NOT NULL UNIQUE, " +
            "event_type VARCHAR(16) NOT NULL, " +
            "event_timestamp TIMESTAMP NOT NULL, " +
            "hash_key_value VARCHAR(2048) NOT NULL, " +
            "sort_key_value VARCHAR(2048), " +
            "keys_json %s NOT NULL, " +
            "old_image_json %s, " +
            "new_image_json %s, " +
            "approximate_creation_time BIGINT NOT NULL, " +
            "size_bytes INT NOT NULL, " +
            "create_date TIMESTAMP NOT NULL" +
            ")",
        tableName,
        autoIncrementType,
        jsonColumnType,
        jsonColumnType,
        jsonColumnType
    );
  }

  /**
   * Sanitizes a table name to prevent SQL injection and ensure valid SQL identifier.
   * Removes special characters and converts to lowercase.
   * Preserves hyphens and underscores as they're common in DynamoDB table names.
   *
   * @param tableName the table name to sanitize
   * @return the sanitized table name
   */
  private String sanitizeTableName(final String tableName) {
    // Replace non-alphanumeric characters (except underscores and hyphens) with underscores
    // Then convert to lowercase for consistency
    return tableName.replaceAll("[^a-zA-Z0-9_-]", "_").toLowerCase();
  }
}
