package com.codeheadsystems.pretender.dao;

import com.codeheadsystems.pretender.model.ImmutablePdbStreamRecord;
import com.codeheadsystems.pretender.model.PdbStreamRecord;
import java.time.Instant;
import java.util.List;
import java.util.Optional;
import javax.inject.Inject;
import javax.inject.Singleton;
import org.jdbi.v3.core.Jdbi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Data access object for stream record operations.
 * Uses JDBI Handle directly to support dynamic stream table names.
 */
@Singleton
public class PdbStreamDao {

  private static final Logger log = LoggerFactory.getLogger(PdbStreamDao.class);

  private final Jdbi jdbi;

  /**
   * Instantiates a new Pdb stream dao.
   *
   * @param jdbi the jdbi
   */
  @Inject
  public PdbStreamDao(final Jdbi jdbi) {
    log.info("PdbStreamDao({})", jdbi);
    this.jdbi = jdbi;
  }

  /**
   * Inserts a new stream record into the table.
   * Note: sequence_number is auto-generated by the database.
   *
   * @param tableName the stream table name (with pdb_stream_ prefix)
   * @param record    the stream record
   * @return true if inserted
   */
  public boolean insert(final String tableName, final PdbStreamRecord record) {
    log.trace("insert({}, {})", tableName, record);

    final String sql = String.format(
        "INSERT INTO \"%s\" (event_id, event_type, event_timestamp, hash_key_value, sort_key_value, " +
            "keys_json, old_image_json, new_image_json, approximate_creation_time, size_bytes, create_date) " +
            "VALUES (:eventId, :eventType, :eventTimestamp, :hashKeyValue, :sortKeyValue, " +
            ":keysJson, :oldImageJson, :newImageJson, :approximateCreationTime, :sizeBytes, :createDate)",
        tableName
    );

    return jdbi.withHandle(handle ->
        handle.createUpdate(sql)
            .bind("eventId", record.eventId())
            .bind("eventType", record.eventType())
            .bind("eventTimestamp", record.eventTimestamp())
            .bind("hashKeyValue", record.hashKeyValue())
            .bind("sortKeyValue", record.sortKeyValue().orElse(null))
            .bind("keysJson", record.keysJson())
            .bind("oldImageJson", record.oldImageJson().orElse(null))
            .bind("newImageJson", record.newImageJson().orElse(null))
            .bind("approximateCreationTime", record.approximateCreationTime())
            .bind("sizeBytes", record.sizeBytes())
            .bind("createDate", record.createDate())
            .execute() > 0
    );
  }

  /**
   * Gets stream records starting from a sequence number.
   *
   * @param tableName      the stream table name
   * @param startSequence  the starting sequence number (exclusive)
   * @param limit          the maximum number of records to return
   * @return the list of stream records
   */
  public List<PdbStreamRecord> getRecords(final String tableName,
                                           final long startSequence,
                                           final int limit) {
    log.trace("getRecords({}, {}, {})", tableName, startSequence, limit);

    final String sql = String.format(
        "SELECT * FROM \"%s\" WHERE sequence_number > :startSequence " +
            "ORDER BY sequence_number ASC LIMIT %d",
        tableName,
        limit
    );

    return jdbi.withHandle(handle ->
        handle.createQuery(sql)
            .bind("startSequence", startSequence)
            .<PdbStreamRecord>map((rs, ctx) -> {
              final ImmutablePdbStreamRecord.Builder builder = ImmutablePdbStreamRecord.builder()
                  .sequenceNumber(rs.getLong("sequence_number"))
                  .eventId(rs.getString("event_id"))
                  .eventType(rs.getString("event_type"))
                  .eventTimestamp(rs.getTimestamp("event_timestamp").toInstant())
                  .hashKeyValue(rs.getString("hash_key_value"))
                  .keysJson(rs.getString("keys_json"))
                  .approximateCreationTime(rs.getLong("approximate_creation_time"))
                  .sizeBytes(rs.getInt("size_bytes"))
                  .createDate(rs.getTimestamp("create_date").toInstant());

              // Handle optional sort key
              final String sortKey = rs.getString("sort_key_value");
              if (sortKey != null) {
                builder.sortKeyValue(sortKey);
              }

              // Handle optional old image
              final String oldImage = rs.getString("old_image_json");
              if (oldImage != null) {
                builder.oldImageJson(oldImage);
              }

              // Handle optional new image
              final String newImage = rs.getString("new_image_json");
              if (newImage != null) {
                builder.newImageJson(newImage);
              }

              return builder.build();
            })
            .list()
    );
  }

  /**
   * Gets the latest (highest) sequence number in the stream.
   *
   * @param tableName the stream table name
   * @return the latest sequence number, or 0 if no records exist
   */
  public long getLatestSequenceNumber(final String tableName) {
    log.trace("getLatestSequenceNumber({})", tableName);

    final String sql = String.format(
        "SELECT COALESCE(MAX(sequence_number), 0) FROM \"%s\"",
        tableName
    );

    return jdbi.withHandle(handle ->
        handle.createQuery(sql)
            .mapTo(Long.class)
            .one()
    );
  }

  /**
   * Gets the trim horizon (oldest available sequence number) in the stream.
   *
   * @param tableName the stream table name
   * @return the trim horizon sequence number, or 0 if no records exist
   */
  public long getTrimHorizon(final String tableName) {
    log.trace("getTrimHorizon({})", tableName);

    final String sql = String.format(
        "SELECT COALESCE(MIN(sequence_number), 0) FROM \"%s\"",
        tableName
    );

    return jdbi.withHandle(handle ->
        handle.createQuery(sql)
            .mapTo(Long.class)
            .one()
    );
  }

  /**
   * Deletes stream records older than the specified cutoff time.
   * Used for 24-hour cleanup.
   *
   * @param tableName   the stream table name
   * @param cutoffTime  the cutoff instant (records older than this will be deleted)
   * @return the number of records deleted
   */
  public int deleteOlderThan(final String tableName, final Instant cutoffTime) {
    log.trace("deleteOlderThan({}, {})", tableName, cutoffTime);

    final String sql = String.format(
        "DELETE FROM \"%s\" WHERE event_timestamp < :cutoffTime",
        tableName
    );

    return jdbi.withHandle(handle ->
        handle.createUpdate(sql)
            .bind("cutoffTime", cutoffTime)
            .execute()
    );
  }

  /**
   * Gets the total count of stream records in the table.
   * Useful for testing and monitoring.
   *
   * @param tableName the stream table name
   * @return the count of records
   */
  public long count(final String tableName) {
    log.trace("count({})", tableName);

    final String sql = String.format(
        "SELECT COUNT(*) FROM \"%s\"",
        tableName
    );

    return jdbi.withHandle(handle ->
        handle.createQuery(sql)
            .mapTo(Long.class)
            .one()
    );
  }
}
